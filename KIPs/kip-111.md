---
kip: 111
title: Online StateDB Pruning & Migration
author: Dongkwang Lee (etahn.kr) <ethan.kr@klaytn.foundation>
discussions-to: 
status: draft
type: Standards Track
category: Storage
created: 2023-05-03
---

<!--You can leave these HTML comments in your merged KIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new KIPs. Note that a KIP number will be assigned by an editor. When opening a pull request to submit your KIP, please use an abbreviated title in the filename, `kip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the KIP.-->
StateDB Pruning은 StateDB(state trie, storage trie)에서 update되어 과거 데이터가 된 node를 삭제해서 StateDB에 최신 데이터만 남겨 storage를 최적화 하기 위한 기술이다. StateDB Migration은 Hot Storage에서 StateDB pruning의 기술을 활용해 삭제할 데이터를 다른 Cold Storage 공간으로 옮겨 Hot / Cold storage로 데이터를 효율적으로 관리할 수 있게 해준다.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
State Trie의 각 노드는 value를 hash 연산해서 얻어진 32 byte hash를 key로 정의해서 Key value 스토리지에 데이터를 저장한다. 이럴 경우 leaf node에서 동일한 값이 생성될 수 있어 trie내부에서 1개의 노드를 여러 노드에서 참조할 수 있다. 이런 문제를 해결하고자 새로운 ExtHash(Extended Hash) 구조를 제안하고, trie node의 다중 참조 문제를 없애 데이터 관리를 쉽게 하고자한다. 

## Motivation
<!--The motivation is critical for KIPs that want to change the Klaytn protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the KIP solves. KIP submissions without sufficient motivation may be rejected outright.-->

 새로운 ExtHash를 State trie에 사용해서 여러 trie-node가 1개의 trie-node를 참조하는 문제를 제거한다. ExtHash는 기존 Hash에 6 byte serial number를 추가해서 만들어진 hash 타입이다. 그 결과 동일한 ExtHash를 갖는 trie-node는 존재할 수 없게 된다. 데이터 중복을 없앳기 때문에 데이터가 증가하지만, 실험결과 감당 가능한 수준으로 판단된다. 
 새로운 데이터가 trie-node에 추가되는 과정에서 trie-node가 업데이트 되면, 업데이트된 trie-node를 queue에 넣는다. 일정 시간(현재 24시간)이 지난 후 queue의 trie-node를 삭제(pruning)하거나 cold storage로 옮겨서(migration) 실행 서버 노드의 IO패턴에 최적화된 스토리지를 구성할 수 있는 기능을 제공한다.

<!-- 이러한 특징으로 인해 과거 블럭의 trie node와 최신 블럭의 trie node가 동일한 trie node를 참조하게 되고, 그로 인해 reference count control이 어려워져 삭제가능한 trie node를 찾기 어려운 문제가 발생한다. StateDB는 trie구조로 되어 있으며, 매 블록이 생성될때마다 최소 5-6개에서 많게는 수만개의 trie-node가 새롭게 생성되고, 새롭게 생성된 개수만큼의 trie-node가 과거 데이터를 저장하는 trie-node로 변하게 된다. 이러한 이유로 Blockchain의 데이터는 꾸준히 증가만 하게 되고, 스토리지 측면에서 지속적으로 용량이 증가만 하게 된다. 블록체인에서 과거데이터도 중요하지만, 최신 데이터 만큼의 활용도나 중요도가 높은 것은 아니다. -->

## Specification
새로운 trie-node용 hash type
```go
const (
	HashLength = 32

	ExtHashLength = 38	// = HashLength + ExtPadLength
	ExtPadLength  = 6	// = 6 byte serial number
)

type (
	Hash    [HashLength]byte		// 기존 Hash type
	ExtHash [ExtHashLength]byte		// 새로운 ExtHash type
)
```

새로운 ExtHash 타입으로 인해 기존 방식으로 MPT(Merkle Patricia Trie)의 hash를 계산하면 Root Hash값이 변함. 
기존의 MPT와 동일한 Root Hash를 얻기 위해 ExtHash를 Hash로 변경해서 RLP encoding하고 Hash를 계산해서 동일한 MPT의 Root Hash를 얻도록 해야함.

```go
        if hash == nil || lenEncoded == 0 {
                // Generate the RLP encoding of the node
                h.tmp.Reset()
                if err := rlp.Encode(&h.tmp, n); err != nil {
                        panic("encode error: " + err.Error())
                }
		// n node의 rlp 인코딩 결과를 ExtHashFilter를 이용해서 ExtHash를 Hash로 변환
                filteredTmp = ExtHashFilter(n, h.tmp)
                if !common.ExtHashActiveFlag {
			// ExtHash를 사용하지 않으면 Hash로 Encoding된 길이를 사용
                        lenEncoded = uint16(len(filteredTmp))
                } else {
			// ExtHash를 사용하면 ExtHash로 Encoding된 길이를 사용
                        lenEncoded = uint16(len(h.tmp))
                }

        }
        if lenEncoded < 32 && !force {
                return n, lenEncoded, tmpHash // Nodes smaller than 32 bytes are stored inside their parent
        }
        if hash == nil {
		// Hash를 얻을 때는 Hash로 Encoding된 Value로 Hash를 계산
                hash = h.makeHashNode(filteredTmp)
        }


func ExtHashFilter(n node, src_rlp sliceBuffer) (reData sliceBuffer) {
	switch node := n.(type) {
	case *fullNode:
		return node.LegacyRLP()
	case *shortNode:
		return node.LegacyRLP()
	}
	return src_rlp
}

// fullNode의 ExtHash를 Hash로 변환
func (n *fullNode) LegacyRLP() (tmp sliceBuffer) {
	tmpNode := &fullNode{
		flags: n.flags,
	}

	for k, child := range n.Children {
		if tmpHashNode, ok := child.(hashNode); ok {
			// ExtHash to Hash
			tmpNode.Children[k] = toHashNode(tmpHashNode[:common.HashLength])
		} else {
			tmpNode.Children[k] = child
		}
	}

	if err := rlp.Encode(&tmp, tmpNode); err != nil {
		panic("encode error: " + err.Error())
	}
	return tmp
}

// shortNoded의 ExtHash를 Hash로 변환
func (n *shortNode) LegacyRLP() (tmp sliceBuffer) {
	tmpNode := &shortNode{
		Key:   n.Key,
		flags: n.flags,
	}

	// ExtHash를 사용한 Account를 Hash를 사용한 Account로 형변환
	if tmpValueNode, ok := n.Val.(valueNode); ok && len(tmpValueNode) > common.ExtHashLength {
		tmpNode.Val = n.Val.(valueNode)
		serializer := account.NewAccountSerializer()
		if err := rlp.Decode(bytes.NewReader(tmpValueNode), serializer); err == nil {
			serializerLH := serializer.TransCopy()
			if err := rlp.Encode(&tmp, serializerLH); err == nil {
				tmpNode.Val = toValueNode(tmp)
				tmp.Reset()
			}
		}
	} else if tmpHashNode, ok := n.Val.(hashNode); ok {
		// ExtHash to Hash
		tmpNode.Val = toHashNode(tmpHashNode[:common.HashLength])
	} else {
		tmpNode.Val = n.Val
	}

	if err := rlp.Encode(&tmp, tmpNode); err != nil {
		panic("encode error: " + err.Error())
	}
	return tmp
}

```

ExtHash를 사용할 경우 ExtHash가 Uniq한 Hash node가 되기 때문에 기존 DB와의 호환성에서 문제가 발생함.
하지만 ExtHash를 사용하지 않고 기존 Hash를 사용할 경우 모든 동작이 기존과 동일.

## Expected Effect

StateDB Pruning / Migration을 통해 다음의 효과를 기대해 본다.
* Hot Data가 저장된 Storage가 500GB로 줄어 고성능 스토리지로 구성할 수 있고
* Cold Data가 저장된 Storage는 고용량 스토리지로 구성해, 용도별 스토리지 비용효율성 증대 
* Hot Data의 size가 줄어 cache hit ratio가 증가. 결과적으로 IO 성능이 증가

But it may give rise to the following changes:
* 다양한 구성 옵션으로 인해 구조의 복잡성이 증대되고,
* blockchain에서 Hash가 다양한 곳에서 쓰이는 만큼 내부 소스를 다양하게 수정해야 하는 문제가 있음 
* ExtHash를 사용할 경우 snap sync를 사용할 수 없는 문제가 있음.

## Backwards Compatibility
* ExtHash의 경우 Archive Sync, Full Sync, Fast Sync가 가능하지만 Snapshot Sync는 불가능함
* ExtHash를 사용하지 않을 경우 기존과 동일하게 동작해서 하위호환 가능.

## Reference

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
