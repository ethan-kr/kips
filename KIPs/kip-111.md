---
kip: 111
title: Online StateDB Pruning & Migration
author: Dongkwang Lee (etahn.kr) <ethan.kr@klaytn.foundation>
discussions-to: 
status: draft
type: Standards Track
category: Storage
created: 2023-05-03
---

<!--You can leave these HTML comments in your merged KIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new KIPs. Note that a KIP number will be assigned by an editor. When opening a pull request to submit your KIP, please use an abbreviated title in the filename, `kip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the KIP.-->
StateDB Pruning is a technology to optimize storage by deleting nodes that have become historical data in StateDB (state trie, storage trie) and leaving only the latest data in StateDB. StateDB Migration uses the technology of StateDB pruning in Hot Storage to move the data to be deleted to another Cold Storage space, which allows you to manage data efficiently with Hot / Cold storage. In other words, StateDB Pruning is a process of deleting old data from the StateDB, while StateDB Migration is a process of moving the deleted data to a Cold Storage space. This can help to optimize storage and improve the performance of the blockchain.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
Each node in the State Trie defines the 32-byte hash of the value as the key, and stores the data in the key-value storage. In this case, the same value can be generated at the leaf node, so a single node can be referenced by multiple nodes inside the trie. To solve this problem, we propose a new ExtHash (Extended Hash) structure, and we want to make data management easier by creating a 1:1 linked trie node structure without the problem of multiple references.

## Motivation
<!--The motivation is critical for KIPs that want to change the Klaytn protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the KIP solves. KIP submissions without sufficient motivation may be rejected outright.-->

아래 그림은 Account 175의 잔고가 27에서 45로 변경될때 state tire와 block간의 연결관계를 그림으로 나타낸 것이다.
![state trie diagram](../assets/kip-111/state_trie_diagram.png)
위 그림에서 붉은 노드는 새로운 데이터로 변경되었다. pruning의 관점에서 봤을때 붉은 노드를 삭제해도 current block의 정보를 처리하는데는 아무런 문제를 일으키지 않는다. 하지만 기존의 Hash은 중복 referenctr가 발생하기 때문에 어느 노드에서 붉은 노드를 참조하고 있는지 알수 없어 삭제할 수가 없었다. reference count 정보를 추가하고 관리할 수도 있겠지만 여러가지 이유(multi thread, 엄청난 노드수)로 쉽지 않다.
 A new ExtHash is used in the State trie to remove the problem of multiple trie-nodes referencing a single trie-node. ExtHash is a Hash type that is created by adding a 7-byte serial number to the legacy hash. As a result, no trie-node with the same ExtHash can exist. Data is increased because data redundancy is eliminated, but it is judged to be at a manageable level as a result of the experiment.
 The biggest reason for introducing ExtHash is to eliminate multiple references. Many of the pruning methods that have been tried so far have had to stop the system or be accompanied by a lot of IO load due to multiple reference problems. The slight data overhead added to ExtHash allows pruning to proceed without system downtime and without worrying about IO load. 


## Specification

### Terminology

Some borrowing of terminology, etc. - Beigepaper : An Ethereum Technical Specification. Author : Micah Daemeron

a. Root Node - The Top (first) node in a tree

b. Child Node - A node Directly connected to an-other node when moving away from the Root.

c. Leaf Node - A node with no children

d. Server Node - It means a server in charge of each role such as Consensus, Governance, Verification, and API in the klaytn network. CN, PN, and EN, which will be described later, are sub-concepts.

e. CN - Consensus Node - Block을 생성하고 합의하고 검증하는 역할을 담당한다. CN노드는 CN노드들 끼리만 연결하며, 외부와의 연결을 PN노드가 대행한다.

f. PN - Proxy Node - CN노드가 CN노드끼리의 통신에 집중할 수 있도록 외부와의 통신을 대행해주고 CN의 백업서버 역할을 담당한다.

g. EN - End Node - 여러 형태의 외부 API요청을 처리하여 CN, PN의 부하를 감소시킬 목적의 서버

h. MPT - Merkle Patrica Trie



### Trie 구조 정의
ExtHash는 State Trie Node에서만 사용한다. Header, Body, Transaction, Reciept등은 중복문제가 발생하지 않기 때문에 32byte hash를 사용한다.
* State Trie Node는 32byte Hash와 39byte ExtHash 중 1가지만 사용된다.
* 기존과 동일하게 동작하는 Server Node에서는 32byte Hash를 사용한다.
* statedb pruning을 사용하는 Server Node에서는 39byte Hash를 사용한다.
```go
ref_32    = 32 byte - Hash
ref_39    = 39 byte - ExtHash
Ref       = ref_32 or ref_39
Leaf      = [ path, val ]
Extension = [ path, Ref ]
Branch    = [ Ref, Ref, ..., Ref, val ]
Account   = [ balance, nonce, storageRoot Ref, codeHash H ]
```

### Merkel Patricia Trie - 32 byte Hash
위에서 정의를 바탕으로 32 byte Hash를 사용해서 Merkel Patricia trie를 간단히 표현해 보면 아래와 같이 표현할 수 있다.
Account 정보는 다음과 같다. ( 참조(https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node) 문서에서 중복 참조가 일어나도록 약간만 수정 )
a711355 : 45.0 ETH
a77d337 : 1.00 WEI
a7f9363 : 1.10 ETH
a77d397 : 1.00 WEI
```go
Diagram-1
            Root("acec...e3c5") - Extension0 [ "a7", "72fd...b753" ]
                                              |
 Branch0 [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ]
                       /                           |                           \ 
 Leaf0 [ "1355", 45.0 ETH ]     Extension1 [ "d3", "127f...6d00" ]      Leaf1 [ "9365", 1.10 ETH ]
                                                         | 
                  Branch1 [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ]
                                               \                   /  
                                              Leaf2 [ "7", 1.00 WEI ]
```

### Merkel Patricia Trie - 39 byte ExtHash
위 32 byte Hash를 39 byte ExtHash 사용해서 Merkel Patricia trie를 간단히 표현해 보면 아래와 같이 표현할 수 있다.
Account 정보는 위와 동일하다.
편의상 xxx1, xxx2식의 표현이 추가된 7바이트를 의미한다.
```go
Diagram-2
            Root("acec...e3c5") - Extension0 [ "a7", "72fd...b753"xxx7 ]
                                               |
 Branch0 [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"945e...f7af"xxx6, 8:N, ..., f:"6c8d...5660"xxx4, val ]
                       /                               |                               \ 
 Leaf0 [ "1355", 45.0 ETH ]      Extension1 [ "d3", "127f...6d00"xxx3 ]       Leaf1 [ "9365", 1.10 ETH ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 WEI ]           Leaf3 [ "7", 1.00 WEI ]
```

### Get the same MPT Root Hash from ExtHash

ExtHash is a hash with 7 bytes added to the original hash. This changes the Root Hash value when calculating the hash of MPT (Merkle Patricia Trie). This can cause a collision with nodes (servers) or past versions of the hash that do not use ExtHash. To solve this problem, when calculating the hash of MPT, you can get the same result as before by removing the last 7 bytes from ExtHash and calculating it. In this section, we will describe the process of getting the MPT Root Hash using the original Hash by changing ExtHash to Hash.

#### ExtHash에서 기존Hash 얻기 - step by step
Diagram-1,2는 Hash와 ExtHash와의 차이점을 보이기 위한 그림이며 Hash가 계산된 완성본의 형태이다.
원래의 Hash가 계산되기 전상태의 메모리상의 MPT를 표현하면 아래처럼 표현할 수 있다.
```go
Diagram-3
            Root - Extension0 [ "a7", Branch0 ]
                                     |
 Branch0 [ 0:N, 1:Leaf0, 2:N, ..., 7:Extension1, 8:N, ..., f:Leaf1, val ]
                   /                       |                    \ 
 Leaf0 [ "1355", 45.0 ETH ]     Extension1 [ "d3", Branch1 ]     Leaf1 [ "9365", 1.10 ETH ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:Leaf2, ..., 9:Leaf3, ..., f:N, val ]
                                          /               \ 
                        Leaf2 [ "7", 1.00 WEI ]       Leaf3 [ "7", 1.00 WEI ]
```
Hash계산은 아래에서 부터 위로 검사하기 때문에 Leaf3에서 위쪽으로 계산합니다.
* Leaf3는 ref_39가 존재하지 않음으로 그냥 Hash를 계산하고 random count "xxx1"을 붙입니다.
  Leaf3의 ref_39는 "5597...7d27"xxx1이 되며 Branch1의 9번 child를 "5597...7d27"xxx1으로 업데이트 합니다.
* Leaf2도 Leaf3와 동일하지만 이번에는 random count가 "xxx2"가 됩니다.
  Leaf2의 ref_39는 "5597...7d27"xxx2가 되며 Branch1의 3번 child를 "5597...7d27"xxx2로 업데이트 합니다.
* Leaf3, Leaf2의 계산 결과를 반영하면 아래처럼 표현됩니다.

```go
Diagram-4
            Root - Extension0 [ "a7", Branch0 ]
                                     |
 Branch0 [ 0:N, 1:Leaf0, 2:N, ..., 7:Extension1, 8:N, ..., f:Leaf1, val ]
                   /                       |                    \ 
 Leaf0 [ "1355", 45.0 ETH ]     Extension1 [ "d3", Branch1 ]     Leaf1 [ "9365", 1.10 ETH ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 WEI ]           Leaf3 [ "7", 1.00 WEI ]
```

* Branch1에는 위 Leaf3, Leaf2에서 업데이트된 2개의 ref_39가 존재합니다. Hash를 계산하기 전에 ref_39를 ref_32로 잠시 변환합니다.
  그러면 Branch1의 Value는 [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ] 이 되며, Diagram-1의 Branch1과 동일한 Value가 되고 Hash를 계산하면 "127f...6d00"가 되고 random count "xxx3"을 붙입니다.
```go
Diagram-4
            Root - Extension0 [ "a7", Branch0 ]
                                     |
     Branch0 [ 0:N, 1:Leaf0, 2:N, ..., 7:Extension1, 8:N, ..., f:Leaf1, val ]
                     /                       |                        \ 
 Leaf0 [ "1355", 45.0 ETH ]    Extension1 [ "d3", "127f...6d00"xxx3 ]   Leaf1 [ "9365", 1.10 ETH ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 WEI ]           Leaf3 [ "7", 1.00 WEI ]
```

* Leaf1, Leaf0에는 ref_39가 없음으로 그냥 Hash를 계산하고, random count xxx4, xxx5를 붙입니다.
  Leaf1 - "6c8d...5660"xxx4, Leaf - "6c8d...5660"xxx5
* Extension1의 Value에는 ref_39가 있어 ref_32로 변환하고 Hash를 계산합니다.
  Extension1의 Value는 [ "d3", "127f...6d00" ]이 되고, Hash로 계산한후 xxx6을 붙이면 "945e...f7af"xxx6이 됩니다.
* Leaf1, Leaf0, Extension1의 결과를 반영하면 아래의 그림이 됩니다.
```go
Diagram-5
                    Root - Extension0 [ "a7", Branch0 ]
                                               |
 Branch0 [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"945e...f7af"xxx6, 8:N, ..., f:"6c8d...5660"xxx4, val ]
                       /                               |                               \ 
 Leaf0 [ "1355", 45.0 ETH ]      Extension1 [ "d3", "127f...6d00"xxx3 ]       Leaf1 [ "9365", 1.10 ETH ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 WEI ]           Leaf3 [ "7", 1.00 WEI ]
```
* Branch0과 Extension0은 Branch1과 Extention1의 과정을 동일하게 적용하면 Diagram-2와 같은 결과가 나오며, Diagram-1과 동일한 Root Hash를 얻게 되어 호환성이 유지 됩니다.


### Pruning
이제는 삭제과정을 설명합니다.

#### 기존 Hash에서의 Pruning
Diagram-1을 Key : Value 형식으로 표현하면 아래와 같습니다.
```go
KeyValue - 1
"acec...e3c5" : Extension0 - [ "a7", "72fd...b753" ]
"72fd...b753" : Branch0    - [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ]
"7323...25a7" : Leaf0      - [ "1355", 45.0 ETH ]
"945e...f7af" : Extension1 - [ "d3", "127f...6d00" ]
"6c8d...5660" : Leaf1      - [ "9365", 1.10 ETH ]
"127f...6d00" : Branch1    - [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ]
"5597...7d27" : Leaf2      - [ "7", 1.00 WEI ]
``` 
* a77d397 account의 잔고가 1.00 WEI에서 2.00 WEI로 변경된다면 Diagram-1은 아래처럼 변합니다.
* 새롭게 업데이트된 Hash는 빨간색의 ref_32입니다.
```go
Diagram-6
            Root("REDD...e3c5") - Extension0' [ "a7", "REDD...b753" ]
                                               |
 Branch0' [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"REDD...f7af", 8:N, ..., f:"6c8d...5660", val ]
                        /                           |                           \ 
 Leaf0 [ "1355", 45.0 ETH ]    Extension1' [ "d3", "REDD...6d00" ]      Leaf1 [ "9365", 1.10 ETH ]
                                                         | 
                 Branch1' [ 0:N, ..., 3:"5597...7d27", ..., 9:"REDD...7d27", ..., f:N, val ]
                                             /                       \
                            Leaf2 [ "7", 1.00 WEI ]             Leaf2' [ "7", 2.00 WEI ]
```
Diagram-6에서 변화된 정보를 Key : Value형식으로 표현하면 아래와 같습니다.

```go
KeyValue - 2
"acec...e3c5" : Extension0 - [ "a7", "72fd...b753" ]
"72fd...b753" : Branch0    - [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ]
"7323...25a7" : Leaf0      - [ "1355", 45.0 ETH ]
"945e...f7af" : Extension1 - [ "d3", "127f...6d00" ]
"6c8d...5660" : Leaf1      - [ "9365", 1.10 ETH ]
"127f...6d00" : Branch1    - [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ]
"5597...7d27" : Leaf2      - [ "7", 1.00 WEI ]
-- ADD NODE --
"REDD...7d27" : Leaf2'     - [ "7", 2.00 WEI ]
"REDD...6d00" : Branch1'   - [ 0:N, ..., 3:"5597...7d27", ..., 9:"REDD...7d27", ..., f:N, val ]
"REDD...f7af" : Extension1'- [ "d3", "REDD...6d00" ]
"REDD...b753" : Branch0'   - [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"REDD...f7af", 8:N, ..., f:"6c8d...5660", val ]
"REDD...e3c5" : Extension0'- [ "a7", "REDD...b753" ]
``` 
Pruning의 관점에서보면 '(프라임)이 붙은 노드들은 업데이트된 노드이기 때문에 변경전의 노드를 지우고 싶습니다. 그런데 Leaf2'의 원본노드인 Leaf2를 지우면 데이터 유실이 됩니다. 왜냐하면 Branch1에서 Leaf2를 중복으로 참조하고 있었기 때문입니다. 지금은 예제이기 때문에 간단히 표현되었지만, 수십억 노드로 연결되어 있는 MPT에서는 어떤 노드가 새롭게 업데이트 되었을때 과거 노드를 지울수 있는지 판단할 수가 없습니다. 그래서 online puning을 진행할 수 없습니다. 

#### ExtHash에서의 Pruning

Diagram-2를 Key : Value 형식으로 표현하면 아래와 같습니다.
```go
KeyValue - 3
"acec...e3c5"     : Extension0 - [ "a7", "72fd...b753"xxx1 ]
"72fd...b753"xxx7 : Branch0    - [ 0:N, 1:"7323...25a7"xxx2, 2:N, ..., 7:"945e...f7af"xxx3, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"7323...25a7"xxx5 : Leaf0      - [ "1355", 45.0 ETH ]
"945e...f7af"xxx6 : Extension1 - [ "d3", "127f...6d00"xxx5 ]
"6c8d...5660"xxx4 : Leaf1      - [ "9365", 1.10 ETH ]
"127f...6d00"xxx3 : Branch1    - [ 0:N, ..., 3:"5597...7d27"xxx6, ..., 9:"5597...7d27"xxx7, ..., f:N, val ]
"5597...7d27"xxx2 : Leaf2      - [ "7", 1.00 WEI ]
"5597...7d27"xxx1 : Leaf3      - [ "7", 1.00 WEI ]
``` 

* a77d397 account의 잔고가 1.00 WEI에서 2.00 WEI로 변경된다면 Diagram-2는 아래처럼 변합니다.
  a77d397에 관련된 ref_39는 모두 새로 계산되어야 하며,  붉은색 처럼 표현됩니다.
```go
Diagram-7
            Root("REDD...e3c5") - Extension0 [ "a7", "REDD...b753"xxxb ]
                                               |
 Branch0 [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"REDD...f7af"xxxa, 8:N, ..., f:"6c8d...5660"xxx4, val ]
                       /                               |                               \ 
 Leaf0 [ "1355", 45.0 ETH ]      Extension1 [ "d3", "REDD...6d00"xxx9 ]       Leaf1 [ "9365", 1.10 ETH ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"REDD...7d27"xxx8, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 WEI ]           Leaf3 [ "7", 2.00 WEI ]
```

Diagram-2에서 Diagram-6으로 변경된 내용을 Key : Value 형식으로 표현하면 아래와 같습니다.
```go
KeyValue - 4
-- OLD NODE --
"acec...e3c5"     : Extension0 - [ "a7", "72fd...b753"xxx1 ]
"72fd...b753"xxx7 : Branch0    - [ 0:N, 1:"7323...25a7"xxx2, 2:N, ..., 7:"945e...f7af"xxx3, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"7323...25a7"xxx5 : Leaf0      - [ "1355", 45.0 ETH ]
"945e...f7af"xxx6 : Extension1 - [ "d3", "127f...6d00"xxx5 ]
"6c8d...5660"xxx4 : Leaf1      - [ "9365", 1.10 ETH ]
"127f...6d00"xxx3 : Branch1    - [ 0:N, ..., 3:"5597...7d27"xxx6, ..., 9:"5597...7d27"xxx7, ..., f:N, val ]
"5597...7d27"xxx2 : Leaf2      - [ "7", 1.00 WEI ]
"5597...7d27"xxx1 : Leaf3      - [ "7", 1.00 WEI ]
-- ADD NODE --
"REDD...7d27"xxx8 : Leaf3'     - [ "7", 2.00 WEI ]
"REDD...6d00"xxx9 : Branch1'   - [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"REDD...7d27"xxx8, ..., f:N, val ]
"REDD...f7af"xxxa : Extension1'- [ "d3", "REDD...6d00"xxx9 ]
"REDD...b753"xxxb : Branch0'   - [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"REDD...f7af"xxxa, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"REDD...e3c5"     : Extension0'- [ "a7", "REDD...b753"xxxb ]
``` 

* Leaf3의 Balance가 변경됨으로 인해 Leaf3', Branch1' Extention1', Branch0', Extension0'으로 새롭게 업데이트 되었고, Pruning의 목적처럼 최신데이터만 유지 한다면 "OLD NODE"에 있던 Leaf3, Branch1, Extention1, Branch0, Extension0를 삭제하면 됩니다.
* 추가된 7바이트로 인해 중복 참조하는 노드가 존재할 수 없기 때문입니다.
* 따라서 "5597...7d27"xxx1, "127f...6d00"xxx3, "945e...f7af"xxx6, "72fd...b753"xxx7, "acec...e3c5"를 삭제할 수 있습니다.
 
#### Pruning을 위해 도입한 ExtHash로 인한 변화

* 데이터 관점에서 보기 위해 KeyValue-1과 KeyValue-3을 이곳에서 다시 보고 비교해봅니다.
```go
KeyValue - 1
"acec...e3c5" : Extension0 - [ "a7", "72fd...b753" ]
"72fd...b753" : Branch0    - [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ]
"7323...25a7" : Leaf0      - [ "1355", 45.0 ETH ]
"945e...f7af" : Extension1 - [ "d3", "127f...6d00" ]
"6c8d...5660" : Leaf1      - [ "9365", 1.10 ETH ]
"127f...6d00" : Branch1    - [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ]
"5597...7d27" : Leaf2      - [ "7", 1.00 WEI ]
``` 

```go
KeyValue - 3
"acec...e3c5"     : Extension0 - [ "a7", "72fd...b753"xxx1 ]
"72fd...b753"xxx7 : Branch0    - [ 0:N, 1:"7323...25a7"xxx2, 2:N, ..., 7:"945e...f7af"xxx3, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"7323...25a7"xxx5 : Leaf0      - [ "1355", 45.0 ETH ]
"945e...f7af"xxx6 : Extension1 - [ "d3", "127f...6d00"xxx5 ]
"6c8d...5660"xxx4 : Leaf1      - [ "9365", 1.10 ETH ]
"127f...6d00"xxx3 : Branch1    - [ 0:N, ..., 3:"5597...7d27"xxx6, ..., 9:"5597...7d27"xxx7, ..., f:N, val ]
"5597...7d27"xxx2 : Leaf2      - [ "7", 1.00 WEI ]
"5597...7d27"xxx1 : Leaf3      - [ "7", 1.00 WEI ]
``` 

* KeyValue - 1, 3은 같은 데이터를 표현하고 있습니다.
* 하지만 추가된 7바이트로 인해 2가지 변화가 있습니다.
* MPT의 모든 Hash가 32 byte에서 39 byte로 증가했으며, Key, Value모두에 적용됩니다. 이로 인해 39/32 만큼 증가해서 최대 21.8%정도의 용량이 증가될 수 있습니다.
* KeyValue - 3에는 KeyValue - 1에 없던 Leaf3이 추가되었습니다. 중복 참조로 인해 데이터를 효율적으로 사용할 수 없게 되었습니다. 이는 각 블록체인의 상황에따라 많이 다를 수 있으나, 클레이튼 내부 조사 결과는 2% 이하로 증가되는 것으로 조사되었습니다.
* 결과적으로 ExtHash를 도입함으로 인해 23% 정도의 데이터가 증가하게 되는 것으로 보고 있습니다.





#### ExtHash Filter
The ExtHashFilter function works as follows.
All trie-nodes in MPT are of type fullNode or shorNode.
If you convert the ExtHash of the two node types to Hash and RLP-encode it, you can get the same value as the RLP encoding of the legacy Hash.
As shown in the code below, the ExtHash is converted to Hash using the LegacyRLP() function for fullNode and shorNode.
And if you RLP-encode the result, you will get the same encoding result as the RLP encoding result of the legacy hash.

```go
func ExtHashFilter(n node) (reData []byte) {
	if 'n' type is fullNode {
		tmpData = fullNodeFilter(n)
	} else if 'n' type is shotNode {
		tmpData = shortNodeFilater(n)
	} else {
		tmpData = rlp.encode(n)	
	} 

	return tmpData
}

func fullNodeFilter(n node) (rlpResult []byte) {

	for i = 0 -> 15 {
		if n[i] == ExtHash Type {
			rlpResult = rlpResult + rlp.encode( n[i][:HashLength] )
		} else {
			rlpResult = rlpResult + rlp.encode( n[i] )
		}
	}
	return rlpResult
}

func shortNodeFilter(n node) (rlpResult []byte) {
	if 'n' is smart contract type {
		rlpResult = rlp.encode( n.storageRoot[:HashLength] ) 
                          + rlp.encode( n.codeHash )
			  + rlp.encode( n.codeinfo )
	} else {
		rlpResult = rlp.encode( n )
	}
	return rlpResult
}
```

#### Calculate Hash 
ExtHash was converted to legay Hash using ExtHashFilter, and RLP encoding result of legacy Hash was obtained. Use this to calculate the hash for hash trie-node verification.
```go

// not use ExtHash process
func storeByHash( n node ) error {
	data = ExtHashFilter(n)
	hash = keccak256(data)

	err = db.put(hash, data)
	return err
}

// use ExtHash process
func storeByExtHash( n node ) error {
	data = rlp.encode(n)
	hash = keccak256(data) + 7 byte random count

	err = db.put(hashm data)
	return errr
}

```

## Expected Effect

Expect the following effects through StateDB Pruning / Migration.
* Storage where hot data is stored is reduced to 500GB, which can be configured as high-performance storage
* Storage where cold data is stored is composed of high-capacity storage to increase storage cost efficiency for each purpose
* The cache hit ratio increases as the size of Hot Data decreases. As a result, IO performance increases

But it may give rise to the following changes:
* Various configuration options increase the complexity of the structure,
* As Hash is used in various places in blockchain, there is a problem that many internal sources need to be modified.
* There is a problem that snap sync cannot be used when using ExtHash.

## Backwards Compatibility
* In the case of ExtHash, Archive Sync, Full Sync, and Fast Sync are possible, but Snapshot Sync is not possible.
* If ExtHash is not used, backward compatibility is possible as it operates the same as before.

## Reference

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
