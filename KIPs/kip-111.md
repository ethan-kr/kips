---
kip: 111
title: Online StateDB Pruning & Migration
author: Dongkwang Lee (etahn.kr) <ethan.kr@klaytn.foundation>
discussions-to: 
status: draft
type: Standards Track
category: Storage
created: 2023-05-03
---

<!--You can leave these HTML comments in your merged KIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new KIPs. Note that a KIP number will be assigned by an editor. When opening a pull request to submit your KIP, please use an abbreviated title in the filename, `kip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the KIP.-->
StateDB Pruning is a technology to optimize storage by deleting nodes that have become historical data in StateDB (state trie, storage trie) and leaving only the latest data in StateDB. StateDB Migration uses the technology of StateDB pruning in Hot Storage to move the data to be deleted to another Cold Storage space, which allows you to manage data efficiently with Hot / Cold storage. In other words, StateDB Pruning is a process of deleting old data from the StateDB, while StateDB Migration is a process of moving the deleted data to a Cold Storage space. This can help to optimize storage and improve the performance of the blockchain.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
Each node in the State Trie defines the 32-byte hash of the value as the key, and stores the data in the key-value storage. In this case, the same value can be generated at the leaf node, so a single node can be referenced by multiple nodes inside the trie. To solve this problem, we propose a new ExtHash (Extended Hash) structure, and we want to make data management easier by creating a 1:1 linked trie node structure without the problem of multiple references.

## Motivation
<!--The motivation is critical for KIPs that want to change the Klaytn protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the KIP solves. KIP submissions without sufficient motivation may be rejected outright.-->

아래 그림은 Account 175의 잔고가 27에서 45로 변경될때 state tire와 block간의 연결관계를 그림으로 나타낸 것이다.
![state trie diagram](../assets/kip-111/state_trie_diagram.png)
위 그림에서 붉은 노드는 새로운 데이터로 변경되었다. pruning의 관점에서 봤을때 붉은 노드를 삭제해도 current block의 정보를 처리하는데는 아무런 문제를 일으키지 않는다. 하지만 기존의 Hash은 중복 referenctr가 발생하기 때문에 어느 노드에서 붉은 노드를 참조하고 있는지 알수 없어 삭제할 수가 없었다. reference count 정보를 추가하고 관리할 수도 있겠지만 여러가지 이유(multi thread, 엄청난 노드수)로 쉽지 않다. 참조 : https://blog.ethereum.org/2015/06/26/state-tree-pruning  
 A new ExtHash is used in the State trie to remove the problem of multiple trie-nodes referencing a single trie-node. ExtHash is a Hash type that is created by adding a 7-byte serial number to the legacy hash. As a result, no trie-node with the same ExtHash can exist. Data is increased because data redundancy is eliminated, but it is judged to be at a manageable level as a result of the experiment.  
 The biggest reason for introducing ExtHash is to eliminate multiple references. Many of the pruning methods that have been tried so far have had to stop the system or be accompanied by a lot of IO load due to multiple reference problems. The slight data overhead added to ExtHash allows pruning to proceed without system downtime and without worrying about IO load. 


## Specification

### 7바이트를 추가한 이유
추가된 7바이트는 ExtHashNonce라고 정의 한다. account 정보가 변경될 때 마다 count가 증가하는 nonce의 이름에서 따온 것이다.
Hash에 ExtHashNonce를 추가한 이유는 Hash중복을 제거해서 중복 참조 문제를 제거하기 위함이다. Hash가 동일해도 추가된 7바이트는 중복이 일어날수 없어 ExtHash는 중복된 값이 나올 수 없다.  
그저 카운터라면 4바이트이거나 8바이트등이 될 수도 있었을 텐데 왜 유독 7바이트가 되었을까? 그 이유는 ExtHash는 state trie, storage trie의 데이터에서 대부분의 데이터를 차지 하기 때문이다. 증가된 바이트 비율만큼 DB사이즈가 증가한다. 따라서 중복이 일어나지 않으면서 제일 작은 값을 찾아야 한다.  

#### 1초에 업데이트 되는 얼마나 될까?
현재 klaytn은 초당 4000 TPS를 처리할 수 있다. smart contract는 1번에 여러 구좌를 업데이트 시켜서 많은 노드 정보를 업데이트 시킬 수도 있다. 따라서 현실적으로 일어나기 어려울 정도로 큰 숫자로 정의해야 한다. 그래서 정한 숫자는 1블럭당 trie node에서 변경되는 노드수는 100만개 이하라고 가정했다.  
ExtHashNonce는 어떻게 관리를 해야할까? 매번 업데이트 될때마다 DB에 넣는 것은 좋은 선택이 아니라고 생각했다. 그래서 시스템의 nano timestamp를 이용하기로 했다. 서버노드가 시작 될때 nano timestamp를 얻고 1바이트만큼 오르쪽으로 shift 연산을 한 값을 ExtHashNonce의 초기 값으로 잡고 새로운 노드가 생성될 때 마다 1씩 증가 시키기로 했다. 이러면 ExtHashNonce의 초기값이 중복될 일은 없다. nano timestamp를 이용한 ExtHashNonce는 1초 동안 몇개의 블록을 담을 수 있는지 계산해 보면
```
 nano timestamp의 1초는    : 1000,000,000
 1 byte shift right        : 1000,000,000 / 256 = 3906250 ( 7 byte )
 1 byte shift right 1 more : 1000,000,000 / 256 / 256 = 15258 ( 6 byte )
```
ExtHashNonce를 6 byte로 정할 경우 초당 15000개 이상의 trie-node가 업데이트되면 count 역전현상이 일어날 수 있고, 시스템이 재부팅 되면 ExtHashNonce는 충돌이 날 수 있다. ExtHashNonce가 7 byte 가 되면 초당 390만개 이상의 trie-node가 업데이트 되어야 하기때문에 충분히 여유로운 숫자이다.


OR

그럼 100년 동안 중복이 일어나지 않으려먼 몇 바이트가 필요할지 계산해 보자.
```
 1 초   : 1000000
 1 시간 : 1000000 * 3600 ( 1시간은 3600초 )
 하루   : 1000000 * 3600 * 24 ( 하루는 24시간 )
 1년    : 1000000 * 3600 * 24 * 365 ( 1년은 365일 )
 100년  : 1000000 * 3600 * 24 * 365 * 100 ( 100년 )
 결과는 = 3153600000000000
 6 byte : 281474976710656
 7 byte : 72057594037927936
```
6바이트로는 부족하고 7바이트로는 충분하다.  


 

초당 생성되는 trie의 노드수는 얼마정도로 봐야 할까? 현재 klaytn은 4000TPS를 처리할 수 있다. 한 구좌의 정보가 바뀌면 평균적으로 7~8개의 노드 정보가 업데이트 된다. smart contrcat는 동시에 여러 구좌의 정보가 업데이트될 수 있기 때문에 더 많은 노드의 정보가 업데이트 된다.  
그럼 1 블럭이 생성될때 업데이트 되는 노드수는 어떠헥 잡아야 할까? 현실적으로  

### Terminology

Some borrowing of terminology, etc. - Beigepaper : An Ethereum Technical Specification. Author : Micah Daemeron

a. Root Node - The Top (first) node in a tree

b. Child Node - A node Directly connected to an-other node when moving away from the Root.

c. Leaf Node - A node with no children

d. Server Node - It means a server in charge of each role such as Consensus, Governance, Verification, and API in the klaytn network. CN, PN, and EN, which will be described later, are sub-concepts.

e. CN - Consensus Node - Block을 생성하고 합의하고 검증하는 역할을 담당한다. CN노드는 CN노드들 끼리만 연결하며, 외부와의 연결을 PN노드가 대행한다.

f. PN - Proxy Node - CN노드가 CN노드끼리의 통신에 집중할 수 있도록 외부와의 통신을 대행해주고 CN의 백업서버 역할을 담당한다.

g. EN - End Node - 여러 형태의 외부 API요청을 처리하여 CN, PN의 부하를 감소시킬 목적의 서버

h. MPT - Merkle Patrica Trie



### Trie 구조 정의
ExtHash는 State Trie Node에서만 사용한다. Header, Body, Transaction, Reciept등은 중복문제가 발생하지 않기 때문에 32byte hash를 사용한다.
* State Trie Node는 32byte Hash와 39byte ExtHash 중 1가지만 사용된다.
* 기존과 동일하게 동작하는 Server Node에서는 32byte Hash를 사용한다.
* statedb pruning을 사용하는 Server Node에서는 39byte Hash를 사용한다.
```
ref_32    = 32 byte - Hash
ref_39    = 39 byte - ExtHash
Ref       = ref_32 or ref_39
Leaf      = [ path, val ]
Extension = [ path, Ref ]
Branch    = [ Ref, Ref, ..., Ref, val ]
Account   = [ balance, nonce, storageRoot Ref, codeHash H ]
```

### Merkel Patricia Trie - 32 byte Hash
위에서 정의를 바탕으로 32 byte Hash를 사용해서 Merkel Patricia trie를 간단히 표현해 보면 아래와 같이 표현할 수 있다.
Account 정보는 다음과 같다. ( 참조(https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node) 문서에서 중복 참조가 일어나도록 약간만 수정 )
a711355 : 45.0 KLAY  
a77d337 : 1.00 ston  
a7f9363 : 1.10 KLAY  
a77d397 : 1.00 ston  
```
Diagram-1
            Root("acec...e3c5") - Extension0 [ "a7", "72fd...b753" ]
                                              |
 Branch0 [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ]
                       /                           |                           \ 
 Leaf0 [ "1355", 45.0 KLAY ]     Extension1 [ "d3", "127f...6d00" ]      Leaf1 [ "9365", 1.10 KLAY ]
                                                         | 
                  Branch1 [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ]
                                               \                   /  
                                              Leaf2 [ "7", 1.00 ston ]
```

### Merkel Patricia Trie - 39 byte ExtHash
위 32 byte Hash를 39 byte ExtHash 사용해서 Merkel Patricia trie를 간단히 표현해 보면 아래와 같이 표현할 수 있다.
Account 정보는 위와 동일하다.
편의상 xxx1, xxx2식의 표현이 추가된 7바이트를 의미한다.
```
Diagram-2
            Root("acec...e3c5") - Extension0 [ "a7", "72fd...b753"xxx7 ]
                                               |
 Branch0 [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"945e...f7af"xxx6, 8:N, ..., f:"6c8d...5660"xxx4, val ]
                       /                               |                               \ 
 Leaf0 [ "1355", 45.0 KLAY ]      Extension1 [ "d3", "127f...6d00"xxx3 ]       Leaf1 [ "9365", 1.10 KLAY ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 ston ]           Leaf3 [ "7", 1.00 ston ]
```

### Get the same MPT Root Hash from ExtHash

ExtHash is a hash with 7 bytes added to the original hash. This changes the Root Hash value when calculating the hash of MPT (Merkle Patricia Trie). This can cause a collision with nodes (servers) or past versions of the hash that do not use ExtHash. To solve this problem, when calculating the hash of MPT, you can get the same result as before by removing the last 7 bytes from ExtHash and calculating it. In this section, we will describe the process of getting the MPT Root Hash using the original Hash by changing ExtHash to Hash.

#### ExtHash에서 기존Hash 얻기 - step by step
Diagram-1,2는 Hash와 ExtHash와의 차이점을 보이기 위한 그림이며 Hash가 계산된 완성본의 형태이다.
원래의 Hash가 계산되기 전상태의 메모리상의 MPT를 표현하면 아래처럼 표현할 수 있다.
```
Diagram-3
            Root - Extension0 [ "a7", Branch0 ]
                                     |
 Branch0 [ 0:N, 1:Leaf0, 2:N, ..., 7:Extension1, 8:N, ..., f:Leaf1, val ]
                   /                       |                    \ 
 Leaf0 [ "1355", 45.0 KLAY ]     Extension1 [ "d3", Branch1 ]     Leaf1 [ "9365", 1.10 KLAY ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:Leaf2, ..., 9:Leaf3, ..., f:N, val ]
                                          /               \ 
                        Leaf2 [ "7", 1.00 ston ]       Leaf3 [ "7", 1.00 ston ]
```
Hash계산은 아래에서 부터 위로 검사하기 때문에 Leaf3에서 위쪽으로 계산합니다.
* Leaf3는 ref_39가 존재하지 않음으로 그냥 Hash를 계산하고 random count "xxx1"을 붙입니다.
  Leaf3의 ref_39는 "5597...7d27"xxx1이 되며 Branch1의 9번 child를 "5597...7d27"xxx1으로 업데이트 합니다.
* Leaf2도 Leaf3와 동일하지만 이번에는 random count가 "xxx2"가 됩니다.
  Leaf2의 ref_39는 "5597...7d27"xxx2가 되며 Branch1의 3번 child를 "5597...7d27"xxx2로 업데이트 합니다.
* Leaf3, Leaf2의 계산 결과를 반영하면 아래처럼 표현됩니다.

```
Diagram-4
            Root - Extension0 [ "a7", Branch0 ]
                                     |
 Branch0 [ 0:N, 1:Leaf0, 2:N, ..., 7:Extension1, 8:N, ..., f:Leaf1, val ]
                   /                       |                    \ 
 Leaf0 [ "1355", 45.0 KLAY ]     Extension1 [ "d3", Branch1 ]     Leaf1 [ "9365", 1.10 KLAY ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 ston ]           Leaf3 [ "7", 1.00 ston ]
```

* Branch1에는 위 Leaf3, Leaf2에서 업데이트된 2개의 ref_39가 존재합니다. Hash를 계산하기 전에 ref_39를 ref_32로 잠시 변환합니다.
  그러면 Branch1의 Value는 [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ] 이 되며, Diagram-1의 Branch1과 동일한 Value가 되고 Hash를 계산하면 "127f...6d00"가 되고 random count "xxx3"을 붙입니다.
```
Diagram-4
            Root - Extension0 [ "a7", Branch0 ]
                                     |
     Branch0 [ 0:N, 1:Leaf0, 2:N, ..., 7:Extension1, 8:N, ..., f:Leaf1, val ]
                     /                       |                        \ 
 Leaf0 [ "1355", 45.0 KLAY ]    Extension1 [ "d3", "127f...6d00"xxx3 ]   Leaf1 [ "9365", 1.10 KLAY ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 ston ]           Leaf3 [ "7", 1.00 ston ]
```

* Leaf1, Leaf0에는 ref_39가 없음으로 그냥 Hash를 계산하고, random count xxx4, xxx5를 붙입니다.
  Leaf1 - "6c8d...5660"xxx4, Leaf - "6c8d...5660"xxx5
* Extension1의 Value에는 ref_39가 있어 ref_32로 변환하고 Hash를 계산합니다.
  Extension1의 Value는 [ "d3", "127f...6d00" ]이 되고, Hash로 계산한후 xxx6을 붙이면 "945e...f7af"xxx6이 됩니다.
* Leaf1, Leaf0, Extension1의 결과를 반영하면 아래의 그림이 됩니다.
```
Diagram-5
                    Root - Extension0 [ "a7", Branch0 ]
                                               |
 Branch0 [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"945e...f7af"xxx6, 8:N, ..., f:"6c8d...5660"xxx4, val ]
                       /                               |                               \ 
 Leaf0 [ "1355", 45.0 KLAY ]      Extension1 [ "d3", "127f...6d00"xxx3 ]       Leaf1 [ "9365", 1.10 KLAY ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"5597...7d27"xxx1, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 ston ]           Leaf3 [ "7", 1.00 ston ]
```
* Branch0과 Extension0은 Branch1과 Extention1의 과정을 동일하게 적용하면 Diagram-2와 같은 결과가 나오며, Diagram-1과 동일한 Root Hash를 얻게 되어 호환성이 유지 됩니다.


### Pruning
이제는 삭제과정을 설명합니다.

#### 기존 Hash에서의 Pruning
Diagram-1을 Key : Value 형식으로 표현하면 아래와 같습니다.
```
KeyValue - 1
"Extension0 - acec...e3c5" : RlpEncode([ "a7", "72fd...b753" ])
"Branch0    - 72fd...b753" : RlpEncode([ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ])
"Leaf0      - 7323...25a7" : RlpEncode([ "1355", 45.0 KLAY ])
"Extension1 - 945e...f7af" : RlpEncode([ "d3", "127f...6d00" ])
"Leaf1      - 6c8d...5660" : RlpEncode([ "9365", 1.10 KLAY ])
"Branch1    - 127f...6d00" : RlpEncode([ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ])
"Leaf2      - 5597...7d27" : RlpEncode([ "7", 1.00 ston ])
``` 
* a77d397 account의 잔고가 1.00 ston에서 2.00 ston로 변경된다면 Diagram-1은 아래처럼 변합니다.
* 새롭게 업데이트된 Hash는 빨간색의 ref_32입니다.
```
Diagram-6
            Root("REDD...e3c5") - Extension0' [ "a7", "REDD...b753" ]
                                               |
 Branch0' [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"REDD...f7af", 8:N, ..., f:"6c8d...5660", val ]
                        /                           |                           \ 
 Leaf0 [ "1355", 45.0 KLAY ]    Extension1' [ "d3", "REDD...6d00" ]      Leaf1 [ "9365", 1.10 KLAY ]
                                                         | 
                 Branch1' [ 0:N, ..., 3:"5597...7d27", ..., 9:"REDD...7d27", ..., f:N, val ]
                                             /                       \
                            Leaf2 [ "7", 1.00 ston ]             Leaf2' [ "7", 2.00 ston ]
```
Diagram-6에서 변화된 정보를 Key : Value형식으로 표현하면 아래와 같습니다.

```
KeyValue - 2
"Extension0 - acec...e3c5" : RlpEncode([ "a7", "72fd...b753" ])
"Branch0    - 72fd...b753" : RlpEncode([ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ])
"Leaf0      - 7323...25a7" : RlpEncode([ "1355", 45.0 KLAY ])
"Extension1 - 945e...f7af" : RlpEncode([ "d3", "127f...6d00" ])
"Leaf1      - 6c8d...5660" : RlpEncode([ "9365", 1.10 KLAY ])
"Branch1    - 127f...6d00" : RlpEncode([ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ])
"Leaf2      - 5597...7d27" : RlpEncode([ "7", 1.00 ston ])
-             - ADD NODE --
"Leaf2'     - REDD...7d27" : RlpEncode([ "7", 2.00 ston ])
"Branch1'   - REDD...6d00" : RlpEncode([ 0:N, ..., 3:"5597...7d27", ..., 9:"REDD...7d27", ..., f:N, val ])
"Extension1'- REDD...f7af" : RlpEncode([ "d3", "REDD...6d00" ])
"Branch0'   - REDD...b753" : RlpEncode([ 0:N, 1:"7323...25a7", 2:N, ..., 7:"REDD...f7af", 8:N, ..., f:"6c8d...5660", val ])
"Extension0'- REDD...e3c5" : RlpEncode([ "a7", "REDD...b753" ])
``` 
Pruning의 관점에서보면 '(프라임)이 붙은 노드들은 업데이트된 노드이기 때문에 변경전의 노드를 지우고 싶습니다. 그런데 Leaf2'의 원본노드인 Leaf2를 지우면 데이터 유실이 됩니다. 왜냐하면 Branch1에서 Leaf2를 중복으로 참조하고 있었기 때문입니다. 지금은 예제이기 때문에 간단히 표현되었지만, 수십억 노드로 연결되어 있는 MPT에서는 어떤 노드가 새롭게 업데이트 되었을때 과거 노드를 지울수 있는지 판단할 수가 없습니다. 그래서 online puning을 진행할 수 없습니다. 

#### ExtHash에서의 Pruning

Diagram-2를 Key : Value 형식으로 표현하면 아래와 같습니다.
```
KeyValue - 3
"Extension0 - acec...e3c5"     : RlpEncode([ "a7", "72fd...b753"xxx1 ])
"Branch0    - 72fd...b753"xxx7 : RlpEncode([ 0:N, 1:"7323...25a7"xxx2, 2:N, ..., 7:"945e...f7af"xxx3, 8:N, ..., f:"6c8d...5660"xxx4, val ])
"Leaf0      - 7323...25a7"xxx5 : RlpEncode([ "1355", 45.0 KLAY ])
"Extension1 - 945e...f7af"xxx6 : RlpEncode([ "d3", "127f...6d00"xxx5 ])
"Leaf1      - 6c8d...5660"xxx4 : RlpEncode([ "9365", 1.10 KLAY ])
"Branch1    - 127f...6d00"xxx3 : RlpEncode([ 0:N, ..., 3:"5597...7d27"xxx6, ..., 9:"5597...7d27"xxx7, ..., f:N, val ])
"Leaf2      - 5597...7d27"xxx2 : RlpEncode([ "7", 1.00 ston ])
"Leaf3      - 5597...7d27"xxx1 : RlpEncode([ "7", 1.00 ston ])
``` 

* a77d397 account의 잔고가 1.00 ston에서 2.00 ston로 변경된다면 Diagram-2는 아래처럼 변합니다.
  a77d397에 관련된 ref_39는 모두 새로 계산되어야 하며,  붉은색 처럼 표현됩니다.
```
Diagram-7
            Root("REDD...e3c5") - Extension0 [ "a7", "REDD...b753"xxxb ]
                                               |
 Branch0 [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"REDD...f7af"xxxa, 8:N, ..., f:"6c8d...5660"xxx4, val ]
                       /                               |                               \ 
 Leaf0 [ "1355", 45.0 KLAY ]      Extension1 [ "d3", "REDD...6d00"xxx9 ]       Leaf1 [ "9365", 1.10 KLAY ]
                                                          | 
                   Branch1 [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"REDD...7d27"xxx8, ..., f:N, val ]
                                             /                            \ 
                              Leaf2 [ "7", 1.00 ston ]           Leaf3 [ "7", 2.00 ston ]
```

Diagram-2에서 Diagram-6으로 변경된 내용을 Key : Value 형식으로 표현하면 아래와 같습니다.
```
KeyValue - 4
-- OLD NODE --
"Extension0 - acec...e3c5"     : [ "a7", "72fd...b753"xxx1 ]
"Branch0    - 72fd...b753"xxx7 : [ 0:N, 1:"7323...25a7"xxx2, 2:N, ..., 7:"945e...f7af"xxx3, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"Leaf0      - 7323...25a7"xxx5 : [ "1355", 45.0 KLAY ]
"Extension1 - 945e...f7af"xxx6 : [ "d3", "127f...6d00"xxx5 ]
"Leaf1      - 6c8d...5660"xxx4 : [ "9365", 1.10 KLAY ]
"Branch1    - 127f...6d00"xxx3 : [ 0:N, ..., 3:"5597...7d27"xxx6, ..., 9:"5597...7d27"xxx7, ..., f:N, val ]
"Leaf2      - 5597...7d27"xxx2 : [ "7", 1.00 ston ]
"Leaf3      - 5597...7d27"xxx1 : [ "7", 1.00 ston ]
-             - ADD NODE --
"Leaf3'     - REDD...7d27"xxx8 : [ "7", 2.00 ston ]
"Branch1'   - REDD...6d00"xxx9 : [ 0:N, ..., 3:"5597...7d27"xxx2, ..., 9:"REDD...7d27"xxx8, ..., f:N, val ]
"Extension1'- REDD...f7af"xxxa : [ "d3", "REDD...6d00"xxx9 ]
"Branch0'   - REDD...b753"xxxb : [ 0:N, 1:"7323...25a7"xxx5, 2:N, ..., 7:"REDD...f7af"xxxa, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"Extension0'- REDD...e3c5"     : [ "a7", "REDD...b753"xxxb ]
``` 

* Leaf3의 Balance가 변경됨으로 인해 Leaf3', Branch1' Extention1', Branch0', Extension0'으로 새롭게 업데이트 되었고, Pruning의 목적처럼 최신데이터만 유지 한다면 "OLD NODE"에 있던 Leaf3, Branch1, Extention1, Branch0, Extension0를 삭제하면 됩니다.
* 추가된 7바이트로 인해 중복 참조하는 노드가 존재할 수 없기 때문입니다.
* 따라서 "5597...7d27"xxx1, "127f...6d00"xxx3, "945e...f7af"xxx6, "72fd...b753"xxx7, "acec...e3c5"를 삭제할 수 있습니다.
 
#### Pruning을 위해 도입한 ExtHash로 인한 변화

* 데이터 관점에서 보기 위해 KeyValue-1과 KeyValue-3을 이곳에서 다시 보고 비교해봅니다.
```
KeyValue - 1
"Extension0 - acec...e3c5" : [ "a7", "72fd...b753" ]
"Branch0    - 72fd...b753" : [ 0:N, 1:"7323...25a7", 2:N, ..., 7:"945e...f7af", 8:N, ..., f:"6c8d...5660", val ]
"Leaf0      - 7323...25a7" : [ "1355", 45.0 KLAY ]
"Extension1 - 945e...f7af" : [ "d3", "127f...6d00" ]
"Leaf1      - 6c8d...5660" : [ "9365", 1.10 KLAY ]
"Branch1    - 127f...6d00" : [ 0:N, ..., 3:"5597...7d27", ..., 9:"5597...7d27", ..., f:N, val ]
"Leaf2      - 5597...7d27" : [ "7", 1.00 ston ]
``` 

```
KeyValue - 3
"Extension0 - acec...e3c5"     : [ "a7", "72fd...b753"xxx1 ]
"Branch0    - 72fd...b753"xxx7 : [ 0:N, 1:"7323...25a7"xxx2, 2:N, ..., 7:"945e...f7af"xxx3, 8:N, ..., f:"6c8d...5660"xxx4, val ]
"Leaf0      - 7323...25a7"xxx5 : [ "1355", 45.0 KLAY ]
"Extension1 - 945e...f7af"xxx6 : [ "d3", "127f...6d00"xxx5 ]
"Leaf1      - 6c8d...5660"xxx4 : [ "9365", 1.10 KLAY ]
"Branch1    - 127f...6d00"xxx3 : [ 0:N, ..., 3:"5597...7d27"xxx6, ..., 9:"5597...7d27"xxx7, ..., f:N, val ]
"Leaf2      - 5597...7d27"xxx2 : [ "7", 1.00 ston ]
"Leaf3      - 5597...7d27"xxx1 : [ "7", 1.00 ston ]
``` 

* KeyValue - 1, 3은 같은 데이터를 표현하고 있습니다.
* 하지만 추가된 7바이트로 인해 2가지 변화가 있습니다.
* MPT의 모든 Hash가 32 byte에서 39 byte로 증가했으며, Key, Value모두에 적용됩니다. 이로 인해 39/32 만큼 증가해서 최대 21.8%정도의 용량이 증가될 수 있습니다.
* KeyValue - 3에는 KeyValue - 1에 없던 Leaf3이 추가되었습니다. 중복 참조로 인해 데이터를 효율적으로 사용할 수 없게 되었습니다. 이는 각 블록체인의 상황에따라 많이 다를 수 있으나, 클레이튼 내부 조사 결과는 2% 이하로 증가되는 것으로 조사되었습니다.
* 결과적으로 ExtHash를 도입함으로 인해 23% 정도의 데이터가 증가하게 되는 것으로 보고 있습니다.








## Expected Effect

### ExtHash를 도입하기 전에 알아야 할 내용들
* ExtHash를 사용하다 Hash로 변경할 순 있지만, 모든 데이터를 변경해야 하기 때문에 어려움이 있고, ExtHash에서 Hash로 마이그레이션할 툴의 개발 계획은 없다.
* Hash방식으로 운영하던 노드를 ExtHash로 마이그레이션 하는 툴도 존재하지 않는다. 대신 klaytn 재단에서 ExtHash로 만들어진 DB를 snapshot으로 주기적으로 업데이트할 예정이다.
* ExtHash를 사용할 경우 Snapsync를 사용할 수 없다. 반대로 사용할 이유도 많이 부족하다. 이미 최적화된 용량의 ExtHash로된 snapshot을 제공하기 때문이다.
* ExtHash를 사용할 경우 State Migration을 할 수 없다. ExtHash는 이미 최신 데이터로만 동작되기 때문에 State Migration이 불필요하다.

Expect the following effects through StateDB Pruning / Migration.
* Storage where hot data is stored is reduced to 500GB, which can be configured as high-performance storage
* Storage where cold data is stored is composed of high-capacity storage to increase storage cost efficiency for each purpose
* The cache hit ratio increases as the size of Hot Data decreases. As a result, IO performance increases

But it may give rise to the following changes:
* Various configuration options increase the complexity of the structure,
* As Hash is used in various places in blockchain, there is a problem that many internal sources need to be modified.
* There is a problem that snap sync cannot be used when using ExtHash.

## Backwards Compatibility
* In the case of ExtHash, Archive Sync, Full Sync, and Fast Sync are possible, but Snapshot Sync is not possible.
* If ExtHash is not used, backward compatibility is possible as it operates the same as before.
* 

## Reference

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
